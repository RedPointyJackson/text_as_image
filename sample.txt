int64_t state[2]; uint64_t rotl(const uint64_t x, int k){ return (x << k) | (x >> (64 - k)); } double to_double(uint64_t x){ return (x >> 11) * (1. / (UINT64_C(1) << 53)); } double get_rand(){ const uint64_t s0 = state[0]; uint64_t s1 = state[1]; const uint64_t result = s0 + s1; s1 ^= s0; state[0] = rotl(s0, 55) ^ s1 ^ (s1 << 14); state[1] = rotl(s1, 36); return to_double(result); } uint64_t djb_hash(char* word){ uint64_t hash = 5381; int64_t c = 0; while ((c = *word++)) hash = ((hash << 5) + hash) + c; return hash; } double* matrix_reader(size_t *element_number){ double* result = malloc(sizeof(double)); size_t el = 0; while (scanf("%lf", result + el) != EOF){ el++; double* new_pointer = realloc(result, (el+1)*sizeof(double)); if(new_pointer) result = new_pointer; else DIE("Could not realloc array (reading input)\n"); } *element_number = el; return result; } size_t roulette(size_t N, double* weights){ double cumsum = 0; double ball = get_rand(); for(size_t i=0;i<N;i++){ cumsum += weights[i]; if (cumsum > ball) { return i; } } } int main(int argc, char *argv[]){ struct arguments arg; arg.has_seed_word = false; arg.omit_populations = false; arg.use_binary = false; arg.noise = 0; argp_parse(&argp, argc, argv, 0, 0, &arg); double t_max = arg.t_max; if (arg.has_seed_word){ seed_from_word(arg.seed_word); if (!arg.use_binary){ printf("#\n"); printf("# Used seed word: %s\n", arg.seed_word); printf("#\n"); } } else { seed_from_system(); } size_t els_readed; double* K_and_populations = matrix_reader(&els_readed); size_t N = (-1+sqrt(1+4*els_readed))/2.0; if (!arg.use_binary){ printf("#\n"); printf("# Readed %zu elements, infered matrix side of %zu\n", els_readed, N); printf("#\n"); } double* K = K_and_populations; int64_t* populations = malloc(N*sizeof(populations)); for(size_t i=0;i<N;i++){ double float_pop = K_and_populations[N*N+i]; if (float_pop != round(float_pop)){ DIE("Some populations are not integers\n"); } populations[i] = float_pop; } size_t L = 0; for(size_t i=0;i<N;i++){ for(size_t j=0;j<N;j++){ if (i != j && K[j+N*i] != 0) L++; } } double* rates = malloc(L*sizeof(*rates)); int64_t* transitions_from = malloc(L*sizeof(*transitions_from)); int64_t* transitions_to = malloc(L*sizeof(*transitions_to)); size_t el = 0; for(size_t i=0;i<N;i++){ for(size_t j=0;j<N;j++){ if (i != j && K[j+N*i] != 0){ rates[el] = K[j+N*i]; transitions_from[el] = j; transitions_to[el] = i; el++; } } } double* a = malloc(L*sizeof(*a)); double t = 0; if (!arg.use_binary){ printf("#\n"); printf("# Used K matrix (by rows): "); for(size_t i=0;i<N*N;i++){ printf("%lf ", K[i]); } printf("\n"); printf("#\n"); printf("# Max t: %lf\n", t_max); printf("#\n"); printf("#\n"); printf("# Initial populations:\n"); printf("# "); for(size_t i=0;i<N;i++){ printf("%"PRId64" ", populations[i]); } printf("\n"); printf("#\n"); printf("# First column t, then transition (from, to) and\n"); printf("# rest if present population of state i.\n"); printf("#\n"); } while (t < t_max){ double total_rate = 0; for(size_t i=0;i<L;i++){ double this_rate = rates[i]; if (this_rate > 0){ this_rate *= 1 + arg.noise*(1-2*get_rand()); } a[i] = this_rate*populations[transitions_from[i]]; total_rate += a[i]; } for(size_t i=0;i<L;i++){ a[i] /= total_rate; } double delta_t = -log(get_rand())/total_rate; t += delta_t; if (arg.use_binary){ fwrite(&t, sizeof(double), 1, stdout); } else { printf("%lf\t", t); } size_t idx = roulette(L, a); if (arg.use_binary){ fwrite(transitions_from + idx, sizeof(int64_t), 1, stdout); fwrite(transitions_to + idx, sizeof(int64_t), 1, stdout); } else { printf("%lf\t", t); printf("%" PRId64 "\t%" PRId64, transitions_from[idx], transitions_to[idx]); } populations[transitions_from[idx]] --; populations[transitions_to[idx]] ++; if (!arg.omit_populations){ if (arg.use_binary){ fwrite(populations, sizeof(int64_t), N, stdout); } else { printf("\t"); for(size_t i=0;i<N;i++){ printf("%" PRId64 "\t", populations[i]); } } } if(!arg.use_binary) printf("\n"); } return 0; }
